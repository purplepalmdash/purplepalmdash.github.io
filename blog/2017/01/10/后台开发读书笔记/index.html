<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><link href=http://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>后台开发读书笔记 &#183; Dash</title><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css><link rel=stylesheet href="https://purplepalmdash.github.io/css/poole.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/hyde.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/poole-overrides.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/hyde-overrides.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/hyde-a.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/custom-additions.css?ref=abc124"><link rel=stylesheet href=https://purplepalmdash.github.io/css/highlight/googlecode.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/docco.min.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/1.10.2/jquery.min.js></script><script type=text/javascript src=/js/html2canvas.js></script><script type=text/javascript>function genPostShot(){var rightNow=new Date();var imageName=rightNow.toISOString().slice(0,16).replace(/(-)|(:)|(T)/g,"");imageName+='.jpg'
html2canvas(document.getElementsByClassName('post'),{background:'#FFFFFF',onrendered:function(canvas){$('#test').attr('href',canvas.toDataURL("image/jpeg"));$('#test').attr('download',imageName);$('#test')[0].click();}});};</script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><link rel=apple-touch-icon-precomposed sizes=144x144 href="http://purplepalmdash.github.io/touch-icon-144-precomposed.png?ref=abc124"><link href="http://purplepalmdash.github.io/favicon.png?ref=abc124" rel=icon><meta name=description content="ReadingDigestsOnServerSideDevelopment"><meta name=keywords content="Reading"></head><body class=theme-base-0c><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><img src=http://purplepalmdash.github.io/images/mylogo.jpeg alt=gravatar><h1><a href=http://purplepalmdash.github.io/>很惭愧，就做了一点微小的工作</a></h1><a href=http://purplepalmdash.github.io/><p>Dash</p></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=http://purplepalmdash.github.io/post/>All Posts</a></li><li class=sidebar-nav-item><a href=http://purplepalmdash.github.io/categories/technology/>Technology</a></li><li class=sidebar-nav-item><a href=http://purplepalmdash.github.io/categories/life/>Life</a></li><li class=sidebar-nav-item><a href=http://purplepalmdash.github.io/categories/linuxtips/>LinuxTips</a></li></ul><ul class=sidebar-nav><li class=sidebar-nav-item><a href=https://github.com/purplepalmdash><i class="fa fa-github-square fa-3x"></i></a><a href=https://cn.linkedin.com/in/yang-feipeng-1b909319><i class="fa fa-linkedin-square fa-3x"></i></a><a href=https://plus.google.com/u/0/106572959364703833986><i class="fa fa-google-plus-square fa-3x"></i></a><a href=https://www.facebook.com/yang.feipeng><i class="fa fa-facebook-square fa-3x"></i></a><a href=https://twitter.com/dashwillfly><i class="fa fa-twitter-square fa-3x"></i></a></li></ul></div></div><div class="content container"><div class=post><h1>后台开发读书笔记</h1><p align=right><a href=javascript:genPostShot()>TurnToJPG --> <i class="fa fa-camera-retro fa-2x"></i></a><a id=test></a></p><hr><span class=post-date>Jan 10, 2017<br><a class=a_cat href=http://purplepalmdash.github.io/categories/technology>Technology</a></span><div id=_toc class=toc><nav id=TableOfContents><ul><li><ul><li><a href=#第一章>第一章</a></li><li><a href=#第二章>第二章</a></li></ul></li></ul></nav></div><p>从图书馆借回来不少书，其中有一本腾讯工程师写的《后台开发核心技术与应用实践》，这本书的内容很浅显易懂，
基本上涵盖了Linux下C++开发在一般公司能用到的范畴。作者也说了，她写书的初衷在于用最短的篇幅讲解实际后台
用到的核心知识点以便读者能快速进入到实际开发中。扫了扫，前两张用来复习准备面试中有关C++的内容不错。</p><p>想提升的就算了，这本书的代码和调试手段都比较初级，实际工作中，需要更多的借助Google和开源社区来完成。</p><p>这里记录的主要是本人对该书里提到的一些概念的理解.</p><h3 id=第一章>第一章</h3><h4 id=函数模板函数重载>函数模板/函数重载</h4><p>1.2函数章节里，关于函数重载和函数模板的理解可以用下面的代码来解释，左边是用函数重载的情形，可以看到一个
同名函数可以有多个参数版本，而右边的函数模板则引用了模板的概念，大大节约了代码行。</p><pre><code>#include&lt;iostream&gt;      					#include&lt;iostream&gt;
using namespace std;    					using namespace std;
int min(int a, int b, int c){   			      |	template&lt;typename T&gt;
							      &gt;	T min(T a,T b,T c){
    if(a&gt;b)a=b; 						    if(a&gt;b)a=b;
    if(a&gt;c)a=c; 						    if(a&gt;c)a=c;
    return a;   						    return a;
}       							}
long long min(long long a,long long b, long long c){          &lt;
    if(a&gt;b)a=b; 					      &lt;
    if(a&gt;c)a=c; 					      &lt;
    return a;   					      &lt;
}       						      &lt;
double min(double a, double b){ //�������������ϵĲ�����ֻ��      &lt;
    if(a-b&gt;(1e-5))a=b;  				      &lt;
    return a;   					      &lt;
}       						      &lt;
int main(){     						int main(){
    int a=1,b=2,c=3;    				      |	   int a=1,b=2,c=3;
    cout&lt;&lt;min(a,b,c)&lt;&lt;endl;     			      |	   cout&lt;&lt;min(a,b,c)&lt;&lt;endl;
    long long a1=100,b1=200,c1=300;     		      |	   long long a1=1000000000,b1=2000000000,c1=3000000000;
    cout&lt;&lt;min(a1,b1,c1)&lt;&lt;endl;  			      |	   cout&lt;&lt;min(a1,b1,c1)&lt;&lt;endl;
    double a2=1.1,b2=2.2;       			      |	   return 0;
    cout&lt;&lt;min(a2,b2)&lt;&lt;endl;     			      &lt;
    return 0;   					      &lt;
}       							}
</code></pre><h4 id=字符数组>字符数组</h4><p>字符数组中，关于strlen()和sizeof()可以作为面试中的题目来问面试者。</p><h4 id=函数与指针>函数与指针</h4><p>函数指针的情形, 注意这里对函数的引用是直接将函数的地址赋给f.</p><pre><code>#include&lt;iostream&gt;
using namespace std;
int Mmin(int x,int y){
     if(x&lt;y)return x;
     return y;
}
int Mmax(int x,int y){
    if(x&gt;y)return x;
    return y;
}
int main(){
    int (*f)(int x,int y);
    int a=10,b=20;
    f=Mmin;   //��Mmin���������ڵ�ַ����f
    cout &lt;&lt; (*f)(a,b)&lt;&lt;endl;
    f=Mmax;  //��Mmax���������ڵ�ַ����f
    cout &lt;&lt; (*f)(a,b)&lt;&lt;endl;
    return 0;
}
</code></pre><h4 id=结构体共用体枚举>结构体/共用体/枚举</h4><p>共用体的定义可以回忆一下：用关键字union来定义，是一种特殊的类。在一个共用体里可以定义多种
不同的数据类型，这些数据类型共享一段内存，在不同的时间里保存不同的数据类型和长度的变量。但是，
同一时间内只能存储一种类型的数据。其存在的目的是为了节省空间。</p><p>判断大小端的程序有点意思:</p><pre><code>#include&lt;iostream&gt;
using namespace std;
union TEST{
    short a;
    char b[sizeof(short)];
};
int main(){
    TEST test;
    test.a=0x0102;// �������ù�����������ֻ�����ù����������еĳ�Ա��
    if(test.b[0]==0x01&amp;&amp;test.b[1]==0x02){
        cout&lt;&lt;&quot;big endian.&quot;&lt;&lt;endl;
    }
    else if(test.b[0]==0x02&amp;&amp;test.b[1]==0x01){
        cout&lt;&lt;&quot;small endian.&quot;&lt;&lt;endl;
    }
    else{
        cout&lt;&lt;&quot;unknown&quot;&lt;&lt;endl;
    }
    return 0;
}
</code></pre><p>枚举要注意类似于下面的题目:</p><pre><code>enum fruits{apple=3,orange,banana=7,bear};
结果为: 3, 4, 7, 8
</code></pre><h4 id=占用字节数的计算>占用字节数的计算</h4><p>鉴于这个题材经常在面试中被问到，单独拎出来写一段：</p><p>Union：</p><pre><code>#include&lt;iostream&gt;
using namespace std; 
union A{
   int a[5];
   char b;
   double c;
};
int main(){
   cout&lt;&lt;sizeof(A)&lt;&lt;endl;
   return 0;
}
</code></pre><p>最长的double(8Byte)对齐，因而占用的大小应该是<code>int(4Byte)*5=20</code>, 而8字节对齐应该是3x8=24。因而运行结果为24</p><p>Struct:</p><pre><code>#include&lt;iostream&gt;
using namespace std; 
struct B{
  char a;
  double b;
  int c;
}test_struct_b;
int main(){
   cout&lt;&lt;sizeof(test_struct_b)&lt;&lt;endl;
   return 0;
}
</code></pre><p>计算方法是：</p><pre><code>char a , 1
补充7
double b, 8
int c, 4
补充4
</code></pre><p>所以结果为1+7+8+4+4=24.</p><p>混合结构体:</p><pre><code>#include&lt;iostream&gt;
using namespace std;
typedef union{
    long i;
    int k[5];
    char c;
} UDATE; 
struct data{
    int cat;
    UDATE cow;
    double dog;
}too; 
UDATE temp; 
int main(){
    cout&lt;&lt;sizeof(struct data)+sizeof(temp)&lt;&lt;endl;
    return 0;
}
</code></pre><p>原书有错：</p><p>sizeof(temp)大小为24, 因为temp是UDATA类型结构。<br>sizeof(struct data)的计算则是结构体大小变化，每个变量需要占据各自独立的空间，依次为:</p><pre><code>int cat: 4
4字节填充(参照double 8字节对齐)
UPDATE cow: 24
double dog: 8
一共为: 4+4+24+8=40
</code></pre><p>综上所述，结果为40+24=64.</p><h4 id=dowhile0的使用>do&mldr;while(0)的使用</h4><p>这个问题可以在面试的时候问面试者。</p><p>例程:</p><pre><code># define Foo(x) do{\
    statement one;\
    statement two;\
}while(0)
</code></pre><p>在宏替换时这样的写法不会破坏以下的情形:</p><pre><code>if(condition)
    statement one;
    statement two;
else
    //.....
</code></pre><p>如果去掉do&mldr;while(0)则会导致else语句孤立而出现编译错误，加了以后，则使得宏展开后，仍然保留了
原始的语义，从而保证程序的正确性。</p><h4 id=extern-c>extern &ldquo;C&rdquo;</h4><p>加这个是为了让编译器将其当成C语言处理。</p><pre><code>#ifdef __cpluscplus
    extern &quot;C&quot; {
#endif 
</code></pre><h3 id=第二章>第二章</h3><h4 id=类与结构体>类与结构体</h4><p>定义的异同:</p><pre><code>class CStudent{         				      |	struct SStudent{
    int num;    					      |	public:
    char name[20];      				      &lt;
    int age;           //��Щ�����ݳ�Ա��Ҳ��Ϊ��Ա����             &lt;
    void display(){   //���ǳ�Ա����      			    void display(){   //���ǳ�Ա����
        cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl;				        cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl;
        cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl;      			        cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl;
        cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl;				        cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl;
    }   						      |	    }                  //����û�зֺ�
};      						      |	private:
CStudent cstu1,cstu2;//������2������    		      |	    int num;
							      &gt;	    char name[20];
							      &gt;	    int age;
							      &gt;	};

</code></pre><h4 id=类的封装性>类的封装性</h4><p>源代码如下:</p><pre><code>➜  0205 cat student.h
class CStudent{
public:
    void display();
private:
    int num;
    char name[20];
    int age;
};
➜  0205 cat main.cpp 
#include&lt;iostream&gt;
#include &quot;student.h&quot; //ע��������˫����
int main(){
    CStudent stu1;//����stu1����
    stu1.display();//ָ��stu1�����ĳ�Ա����
    return 0;
}
➜  0205 cat student.cpp 
#include&lt;iostream&gt;
#include &quot;student.h&quot; //������Ҫinclude����ͷ�ļ��������޷��ҵ�Student��
using namespace std; 
void CStudent::display(){  //����Ҫע����Student����
    cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl;
    cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl;
    cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl;
}
</code></pre><p>运行结果:</p><pre><code>num:4196688
name:
age:0
</code></pre><p>这样的结果是因为没有对数据成员进行初始化而导致的。</p><h4 id=构造函数>构造函数</h4><p>更改上面的代码:</p><pre><code>➜  0205_1 cat student.h
class CStudent{
public:
    CStudent() {
      num = 0;
      age = 0;
    }
    void display();
private:
    int num;
    char name[20];
    int age;
};
➜  0205_1 ./test 
num:0
name:
age:0
</code></pre><h4 id=静态数据成员>静态数据成员</h4><p>例子:</p><pre><code>➜  chapter02 cat ./0212.cpp 
#include&lt;iostream&gt;
using namespace std;
class Base{
public:
    static int var;
};
int Base::var=10;
class Derived:public Base{
};
int main(){
    Base base1;
    base1.var++;//ͨ������������
    cout&lt;&lt;base1.var&lt;&lt;endl;//����11
    Base base2;
    base2.var++;
    cout&lt;&lt;base2.var&lt;&lt;endl;//����12
    Derived derived1;
    derived1.var++; 
    cout&lt;&lt;derived1.var&lt;&lt;endl;//����13
    Base::var++;//ͨ����������
    cout&lt;&lt;derived1.var&lt;&lt;endl;//����14
    return 0;
}
➜  chapter02 ./0212
11
12
13
14
</code></pre><h4 id=对象存储空间>对象存储空间</h4><p>这个和第一章的存储空间可以结合起来看。</p><p>空类的存储空间为1:</p><pre><code>➜  chapter02 cat 0214.cpp 
#include&lt;iostream&gt;
using namespace std;
class CBox{
};
int main(){
    CBox boxobj;
    cout&lt;&lt;sizeof(boxobj)&lt;&lt;endl;//����1
    return 0;
}
➜  chapter02 ./0214
1
</code></pre><p>有成员变量的类的存储空间:</p><pre><code>➜  chapter02 cat 0215.cpp 
#include&lt;iostream&gt;
using namespace std;
class CBox{
    int length,width,height;
};
int main(){
    CBox boxobj;
    cout&lt;&lt;sizeof(boxobj)&lt;&lt;endl;
    return 0;
}
➜  chapter02 ./0215
12
</code></pre><p>有静态成员变量时，静态成员变量不占据对象的内存空间:</p><pre><code>➜  chapter02 cat 0216.cpp 
#include&lt;iostream&gt;
using namespace std;
class CBox{
    int length,width,height;
    static int count;
};
int main(){
    CBox boxobj;
    cout&lt;&lt;sizeof(boxobj)&lt;&lt;endl;
    return 0;
}
➜  chapter02 ./0216
12
</code></pre><p>成员函数不占据空间:</p><pre><code>➜  chapter02 cat 0217.cpp 
#include&lt;iostream&gt;
using namespace std;
class CBox{
    int foo();
};
int main(){
    CBox boxobj;
    cout&lt;&lt;sizeof(boxobj)&lt;&lt;endl;
    return 0;
}
➜  chapter02 ./0217
1
</code></pre><p>构造函数与析构函数也不占据空间:</p><pre><code>class CBox{
public:
    CBox(){};
    ~CBox(){};
};
大小为1
</code></pre><p>虚析构函数，占用大小为8:</p><pre><code>class CBox{
public:
    CBox(){};
    virtual ~CBox(){};
};
大小为8
</code></pre><h4 id=类模板>类模板</h4><p>操作整数的类与操作浮点数的类:</p><pre><code>class Operation_int{    				      |	class Operation_double{
public: 							public:
    Operation_int(int a,int b):x(a),y(b){}      	      |	    Operation_double(double a, double b):x(a),y(b){}
    int add(){  					      |	    double add(){
        return x+y;     					        return x+y;
    }   							    }
    int subtract(){     				      |	    double subtract(){
        return x-y;     					        return x-y;
    }   							    }
private:							private:
    int x,y;    					      |	    double x,y;
};      							};

</code></pre><p>用类模板来抽象:</p><pre><code>#include &lt;iostream&gt;
using namespace std;
template&lt;class T&gt;//����һ��ģ�壬����������ΪT
class Operation {
public:
    Operation (T a, T b):x(a),y(b){}
    T add(){
        return x+y;
    }
    T subtract(){
        return x-y;
    }
private:
    T x,y;
};
int main(){
    Operation &lt;int&gt; op_int(1,2);
    cout&lt;&lt;op_int.add()&lt;&lt;&quot; &quot;&lt;&lt;op_int.subtract()&lt;&lt;endl;//����3��-1
    Operation &lt;double&gt; op_double(1.2,2.3);
    cout&lt;&lt;op_double.add()&lt;&lt;&quot; &quot;&lt;&lt;op_double.subtract()&lt;&lt;endl;//����3.5��-1.1
    return 0;
}
➜  chapter02 ./0224
3 -1
3.5 -1.1
</code></pre><h4 id=虚函数纯虚函数>虚函数/纯虚函数</h4><p>虚函数可以使得基类指针访问派生类中的同名函数:<br>而纯虚函数则是因为：用基类本身生成对象不合情理，例如用动物作为基类来抽象具体的动物，而动物这个基类
本身是不能被实例化的。</p><p>析构函数不是虚函数时，容易引发内存泄漏:</p><pre><code>➜  chapter02 ./0231
Base::Base()
Derive::Derive()
Base::~Base()
➜  chapter02 cat 0231.cpp 
#include&lt;iostream&gt;
using namespace std;
class Base{
public:
    Base(){ std::cout&lt;&lt;&quot;Base::Base()&quot;&lt;&lt;std::endl; }
    ~Base(){ std::cout&lt;&lt;&quot;Base::~Base()&quot;&lt;&lt;std::endl; }
};
class Derive:public Base{
public:
    Derive(){ std::cout&lt;&lt;&quot;Derive::Derive()&quot;&lt;&lt;std::endl; }
    ~Derive(){ std::cout&lt;&lt;&quot;Derive::~Derive()&quot;&lt;&lt;std::endl; }
};
int main(){
    Base* pBase = new Derive(); 
    /*����base classed������Ŀ����Ϊ������&quot;ͨ��base class�ӿڴ���derived class����&quot;*/
    delete pBase;
    return 0;
}
</code></pre><p>这是由C++的定义指出的：如果一个派生类对象经由一个基类指针被删除，而该基类带有一个非虚析构函数，则会导致
派生类中的成分没被销毁。</p><p>所以，需要把析构函数定义为虚函数。</p><pre><code>➜  chapter02 ./0232
Base::Base()
Derive::Derive()
Derive::~Derive()
Base::~Base()
➜  chapter02 cat 0232.cpp 
#include&lt;iostream&gt;
using namespace std;
class Base{
public:
    Base(){ std::cout&lt;&lt;&quot;Base::Base()&quot;&lt;&lt;std::endl; }
    virtual ~Base(){ std::cout&lt;&lt;&quot;Base::~Base()&quot;&lt;&lt;std::endl; }
};

class Derive:public Base{
public:
    Derive(){ std::cout&lt;&lt;&quot;Derive::Derive()&quot;&lt;&lt;std::endl; }
    ~Derive(){ std::cout&lt;&lt;&quot;Derive::~Derive()&quot;&lt;&lt;std::endl; }
};

int main(){
    Base* pBase = new Derive();
    delete pBase;
    return 0;
}
</code></pre><h4 id=单例模式>单例模式</h4><p>理解：一台计算机上可以连好几台打印机，但是打印程序只能有一个，这里就可以通过单例模式来避免两个打印作业
被同时输出到打印机中。</p><pre><code>➜  chapter02 ./0233
s1=s2
➜  chapter02 cat 0233.cpp 
#include&lt;iostream&gt;
using namespace std;
class CSingleton{
private:
	CSingleton(){   //构造函数是私有的
	}
	static CSingleton *m_pInstance;
public:
	static CSingleton * GetInstance(){
        if(m_pInstance == NULL)  //判断是否是第一次调用
	        m_pInstance = new CSingleton();
	    return m_pInstance;
	}
};
CSingleton * CSingleton::m_pInstance=NULL;//初始化静态成员变量
int main(){
    CSingleton *s1= CSingleton::GetInstance();
    CSingleton *s2= CSingleton::GetInstance();
    if(s1==s2){
        cout&lt;&lt;&quot;s1=s2&quot;&lt;&lt;endl; 
    }
    return 0;
}
</code></pre><p>单例类的特点：</p><pre><code>1. 有指向唯一实例的静态指针m_pInstance，且为私有。   
2. 有一个公有函数用于获取唯一的实例。
3. 构造函数是私有的，不能在别处创建该类的实例.
</code></pre></div></div><script src=http://purplepalmdash.github.io/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>