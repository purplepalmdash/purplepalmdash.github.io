<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta name=generator content="Hugo 0.64.0"><link href=http://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Dash &#183; Dash</title><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css><link rel=stylesheet href="https://purplepalmdash.github.io/css/poole.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/hyde.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/poole-overrides.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/hyde-overrides.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/hyde-a.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/custom-additions.css?ref=abc124"><link rel=stylesheet href=https://purplepalmdash.github.io/css/highlight/googlecode.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/docco.min.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/1.10.2/jquery.min.js></script><script type=text/javascript src=/js/html2canvas.js></script><script type=text/javascript>function genPostShot(){var rightNow=new Date();var imageName=rightNow.toISOString().slice(0,16).replace(/(-)|(:)|(T)/g,"");imageName+='.jpg'
html2canvas(document.getElementsByClassName('post'),{background:'#FFFFFF',onrendered:function(canvas){$('#test').attr('href',canvas.toDataURL("image/jpeg"));$('#test').attr('download',imageName);$('#test')[0].click();}});};</script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><link rel=apple-touch-icon-precomposed sizes=144x144 href="http://purplepalmdash.github.io/touch-icon-144-precomposed.png?ref=abc124"><link href="http://purplepalmdash.github.io/favicon.png?ref=abc124" rel=icon><link href=%7balternate%20%7bRSS%20application/rss+xml%20%20index%20alternate%20%20false%20false%20true%20false%20false%200%7d%20/index.xml%20http://purplepalmdash.github.io/index.xml%7d rel=alternate type=application/rss+xml title="Dash &#183; Dash"><meta name=description content><meta name=keywords content="unix,virtualization,embedded,linux"></head><body class=theme-base-0c><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><img src=http://purplepalmdash.github.io/images/mylogo.jpeg alt=gravatar><h1><a href=http://purplepalmdash.github.io/>很惭愧，就做了一点微小的工作</a></h1><a href=http://purplepalmdash.github.io/><p>Dash</p></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=http://purplepalmdash.github.io/post/>All Posts</a></li><li class=sidebar-nav-item><a href=http://purplepalmdash.github.io/categories/technology/>Technology</a></li><li class=sidebar-nav-item><a href=http://purplepalmdash.github.io/categories/life/>Life</a></li><li class=sidebar-nav-item><a href=http://purplepalmdash.github.io/categories/linuxtips/>LinuxTips</a></li></ul><ul class=sidebar-nav><li class=sidebar-nav-item><a href=https://github.com/purplepalmdash><i class="fa fa-github-square fa-3x"></i></a><a href=https://cn.linkedin.com/in/yang-feipeng-1b909319><i class="fa fa-linkedin-square fa-3x"></i></a><a href=https://plus.google.com/u/0/106572959364703833986><i class="fa fa-google-plus-square fa-3x"></i></a><a href=https://www.facebook.com/yang.feipeng><i class="fa fa-facebook-square fa-3x"></i></a><a href=https://twitter.com/dashwillfly><i class="fa fa-twitter-square fa-3x"></i></a></li></ul></div></div><div class="content container"><div class=posts><div class=post><h1 class=post-title><a href=http://purplepalmdash.github.io/blog/2017/01/10/%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>后台开发读书笔记</a></h1><span class=post-date>Jan 10, 2017<br><a class=a_cat href=http://purplepalmdash.github.io/categories/technology>Technology</a></span><p>从图书馆借回来不少书，其中有一本腾讯工程师写的《后台开发核心技术与应用实践》，这本书的内容很浅显易懂，
基本上涵盖了Linux下C++开发在一般公司能用到的范畴。作者也说了，她写书的初衷在于用最短的篇幅讲解实际后台
用到的核心知识点以便读者能快速进入到实际开发中。扫了扫，前两张用来复习准备面试中有关C++的内容不错。</p><p>想提升的就算了，这本书的代码和调试手段都比较初级，实际工作中，需要更多的借助Google和开源社区来完成。</p><p>这里记录的主要是本人对该书里提到的一些概念的理解.</p><h3 id=第一章>第一章</h3><h4 id=函数模板函数重载>函数模板/函数重载</h4><p>1.2函数章节里，关于函数重载和函数模板的理解可以用下面的代码来解释，左边是用函数重载的情形，可以看到一个
同名函数可以有多个参数版本，而右边的函数模板则引用了模板的概念，大大节约了代码行。</p><pre><code>#include&lt;iostream&gt;      					#include&lt;iostream&gt;
using namespace std;    					using namespace std;
int min(int a, int b, int c){   			      |	template&lt;typename T&gt;
							      &gt;	T min(T a,T b,T c){
    if(a&gt;b)a=b; 						    if(a&gt;b)a=b;
    if(a&gt;c)a=c; 						    if(a&gt;c)a=c;
    return a;   						    return a;
}       							}
long long min(long long a,long long b, long long c){          &lt;
    if(a&gt;b)a=b; 					      &lt;
    if(a&gt;c)a=c; 					      &lt;
    return a;   					      &lt;
}       						      &lt;
double min(double a, double b){ //�������������ϵĲ�����ֻ��      &lt;
    if(a-b&gt;(1e-5))a=b;  				      &lt;
    return a;   					      &lt;
}       						      &lt;
int main(){     						int main(){
    int a=1,b=2,c=3;    				      |	   int a=1,b=2,c=3;
    cout&lt;&lt;min(a,b,c)&lt;&lt;endl;     			      |	   cout&lt;&lt;min(a,b,c)&lt;&lt;endl;
    long long a1=100,b1=200,c1=300;     		      |	   long long a1=1000000000,b1=2000000000,c1=3000000000;
    cout&lt;&lt;min(a1,b1,c1)&lt;&lt;endl;  			      |	   cout&lt;&lt;min(a1,b1,c1)&lt;&lt;endl;
    double a2=1.1,b2=2.2;       			      |	   return 0;
    cout&lt;&lt;min(a2,b2)&lt;&lt;endl;     			      &lt;
    return 0;   					      &lt;
}       							}
</code></pre><h4 id=字符数组>字符数组</h4><p>字符数组中，关于strlen()和sizeof()可以作为面试中的题目来问面试者。</p><h4 id=函数与指针>函数与指针</h4><p>函数指针的情形, 注意这里对函数的引用是直接将函数的地址赋给f.</p><pre><code>#include&lt;iostream&gt;
using namespace std;
int Mmin(int x,int y){
     if(x&lt;y)return x;
     return y;
}
int Mmax(int x,int y){
    if(x&gt;y)return x;
    return y;
}
int main(){
    int (*f)(int x,int y);
    int a=10,b=20;
    f=Mmin;   //��Mmin���������ڵ�ַ����f
    cout &lt;&lt; (*f)(a,b)&lt;&lt;endl;
    f=Mmax;  //��Mmax���������ڵ�ַ����f
    cout &lt;&lt; (*f)(a,b)&lt;&lt;endl;
    return 0;
}
</code></pre><h4 id=结构体共用体枚举>结构体/共用体/枚举</h4><p>共用体的定义可以回忆一下：用关键字union来定义，是一种特殊的类。在一个共用体里可以定义多种
不同的数据类型，这些数据类型共享一段内存，在不同的时间里保存不同的数据类型和长度的变量。但是，
同一时间内只能存储一种类型的数据。其存在的目的是为了节省空间。</p><p>判断大小端的程序有点意思:</p><pre><code>#include&lt;iostream&gt;
using namespace std;
union TEST{
    short a;
    char b[sizeof(short)];
};
int main(){
    TEST test;
    test.a=0x0102;// �������ù�����������ֻ�����ù����������еĳ�Ա��
    if(test.b[0]==0x01&amp;&amp;test.b[1]==0x02){
        cout&lt;&lt;&quot;big endian.&quot;&lt;&lt;endl;
    }
    else if(test.b[0]==0x02&amp;&amp;test.b[1]==0x01){
        cout&lt;&lt;&quot;small endian.&quot;&lt;&lt;endl;
    }
    else{
        cout&lt;&lt;&quot;unknown&quot;&lt;&lt;endl;
    }
    return 0;
}
</code></pre><p>枚举要注意类似于下面的题目:</p><pre><code>enum fruits{apple=3,orange,banana=7,bear};
结果为: 3, 4, 7, 8
</code></pre><h4 id=占用字节数的计算>占用字节数的计算</h4><p>鉴于这个题材经常在面试中被问到，单独拎出来写一段：</p><p>Union：</p><pre><code>#include&lt;iostream&gt;
using namespace std; 
union A{
   int a[5];
   char b;
   double c;
};
int main(){
   cout&lt;&lt;sizeof(A)&lt;&lt;endl;
   return 0;
}
</code></pre><p>最长的double(8Byte)对齐，因而占用的大小应该是<code>int(4Byte)*5=20</code>, 而8字节对齐应该是3x8=24。因而运行结果为24</p><p>Struct:</p><pre><code>#include&lt;iostream&gt;
using namespace std; 
struct B{
  char a;
  double b;
  int c;
}test_struct_b;
int main(){
   cout&lt;&lt;sizeof(test_struct_b)&lt;&lt;endl;
   return 0;
}
</code></pre><p>计算方法是：</p><pre><code>char a , 1
补充7
double b, 8
int c, 4
补充4
</code></pre><p>所以结果为1+7+8+4+4=24.</p><p>混合结构体:</p><pre><code>#include&lt;iostream&gt;
using namespace std;
typedef union{
    long i;
    int k[5];
    char c;
} UDATE; 
struct data{
    int cat;
    UDATE cow;
    double dog;
}too; 
UDATE temp; 
int main(){
    cout&lt;&lt;sizeof(struct data)+sizeof(temp)&lt;&lt;endl;
    return 0;
}
</code></pre><p>原书有错：</p><p>sizeof(temp)大小为24, 因为temp是UDATA类型结构。<br>sizeof(struct data)的计算则是结构体大小变化，每个变量需要占据各自独立的空间，依次为:</p><pre><code>int cat: 4
4字节填充(参照double 8字节对齐)
UPDATE cow: 24
double dog: 8
一共为: 4+4+24+8=40
</code></pre><p>综上所述，结果为40+24=64.</p><h4 id=dowhile0的使用>do&mldr;while(0)的使用</h4><p>这个问题可以在面试的时候问面试者。</p><p>例程:</p><pre><code># define Foo(x) do{\
    statement one;\
    statement two;\
}while(0)
</code></pre><p>在宏替换时这样的写法不会破坏以下的情形:</p><pre><code>if(condition)
    statement one;
    statement two;
else
    //.....
</code></pre><p>如果去掉do&mldr;while(0)则会导致else语句孤立而出现编译错误，加了以后，则使得宏展开后，仍然保留了
原始的语义，从而保证程序的正确性。</p><h4 id=extern-c>extern &ldquo;C&rdquo;</h4><p>加这个是为了让编译器将其当成C语言处理。</p><pre><code>#ifdef __cpluscplus
    extern &quot;C&quot; {
#endif 
</code></pre><h3 id=第二章>第二章</h3><h4 id=类与结构体>类与结构体</h4><p>定义的异同:</p><pre><code>class CStudent{         				      |	struct SStudent{
    int num;    					      |	public:
    char name[20];      				      &lt;
    int age;           //��Щ�����ݳ�Ա��Ҳ��Ϊ��Ա����             &lt;
    void display(){   //���ǳ�Ա����      			    void display(){   //���ǳ�Ա����
        cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl;				        cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl;
        cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl;      			        cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl;
        cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl;				        cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl;
    }   						      |	    }                  //����û�зֺ�
};      						      |	private:
CStudent cstu1,cstu2;//������2������    		      |	    int num;
							      &gt;	    char name[20];
							      &gt;	    int age;
							      &gt;	};

</code></pre><h4 id=类的封装性>类的封装性</h4><p>源代码如下:</p><pre><code>➜  0205 cat student.h
class CStudent{
public:
    void display();
private:
    int num;
    char name[20];
    int age;
};
➜  0205 cat main.cpp 
#include&lt;iostream&gt;
#include &quot;student.h&quot; //ע��������˫����
int main(){
    CStudent stu1;//����stu1����
    stu1.display();//ָ��stu1�����ĳ�Ա����
    return 0;
}
➜  0205 cat student.cpp 
#include&lt;iostream&gt;
#include &quot;student.h&quot; //������Ҫinclude����ͷ�ļ��������޷��ҵ�Student��
using namespace std; 
void CStudent::display(){  //����Ҫע����Student����
    cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl;
    cout&lt;&lt;&quot;name:&quot;&lt;&lt;name&lt;&lt;endl;
    cout&lt;&lt;&quot;age:&quot;&lt;&lt;age&lt;&lt;endl;
}
</code></pre><p>运行结果:</p><pre><code>num:4196688
name:
age:0
</code></pre><p>这样的结果是因为没有对数据成员进行初始化而导致的。</p><h4 id=构造函数>构造函数</h4><p>更改上面的代码:</p><pre><code>➜  0205_1 cat student.h
class CStudent{
public:
    CStudent() {
      num = 0;
      age = 0;
    }
    void display();
private:
    int num;
    char name[20];
    int age;
};
➜  0205_1 ./test 
num:0
name:
age:0
</code></pre><h4 id=静态数据成员>静态数据成员</h4><p>例子:</p><pre><code>➜  chapter02 cat ./0212.cpp 
#include&lt;iostream&gt;
using namespace std;
class Base{
public:
    static int var;
};
int Base::var=10;
class Derived:public Base{
};
int main(){
    Base base1;
    base1.var++;//ͨ������������
    cout&lt;&lt;base1.var&lt;&lt;endl;//����11
    Base base2;
    base2.var++;
    cout&lt;&lt;base2.var&lt;&lt;endl;//����12
    Derived derived1;
    derived1.var++; 
    cout&lt;&lt;derived1.var&lt;&lt;endl;//����13
    Base::var++;//ͨ����������
    cout&lt;&lt;derived1.var&lt;&lt;endl;//����14
    return 0;
}
➜  chapter02 ./0212
11
12
13
14
</code></pre><h4 id=对象存储空间>对象存储空间</h4><p>这个和第一章的存储空间可以结合起来看。</p><p>空类的存储空间为1:</p><pre><code>➜  chapter02 cat 0214.cpp 
#include&lt;iostream&gt;
using namespace std;
class CBox{
};
int main(){
    CBox boxobj;
    cout&lt;&lt;sizeof(boxobj)&lt;&lt;endl;//����1
    return 0;
}
➜  chapter02 ./0214
1
</code></pre><p>有成员变量的类的存储空间:</p><pre><code>➜  chapter02 cat 0215.cpp 
#include&lt;iostream&gt;
using namespace std;
class CBox{
    int length,width,height;
};
int main(){
    CBox boxobj;
    cout&lt;&lt;sizeof(boxobj)&lt;&lt;endl;
    return 0;
}
➜  chapter02 ./0215
12
</code></pre><p>有静态成员变量时，静态成员变量不占据对象的内存空间:</p><pre><code>➜  chapter02 cat 0216.cpp 
#include&lt;iostream&gt;
using namespace std;
class CBox{
    int length,width,height;
    static int count;
};
int main(){
    CBox boxobj;
    cout&lt;&lt;sizeof(boxobj)&lt;&lt;endl;
    return 0;
}
➜  chapter02 ./0216
12
</code></pre><p>成员函数不占据空间:</p><pre><code>➜  chapter02 cat 0217.cpp 
#include&lt;iostream&gt;
using namespace std;
class CBox{
    int foo();
};
int main(){
    CBox boxobj;
    cout&lt;&lt;sizeof(boxobj)&lt;&lt;endl;
    return 0;
}
➜  chapter02 ./0217
1
</code></pre><p>构造函数与析构函数也不占据空间:</p><pre><code>class CBox{
public:
    CBox(){};
    ~CBox(){};
};
大小为1
</code></pre><p>虚析构函数，占用大小为8:</p><pre><code>class CBox{
public:
    CBox(){};
    virtual ~CBox(){};
};
大小为8
</code></pre><h4 id=类模板>类模板</h4><p>操作整数的类与操作浮点数的类:</p><pre><code>class Operation_int{    				      |	class Operation_double{
public: 							public:
    Operation_int(int a,int b):x(a),y(b){}      	      |	    Operation_double(double a, double b):x(a),y(b){}
    int add(){  					      |	    double add(){
        return x+y;     					        return x+y;
    }   							    }
    int subtract(){     				      |	    double subtract(){
        return x-y;     					        return x-y;
    }   							    }
private:							private:
    int x,y;    					      |	    double x,y;
};      							};

</code></pre><p>用类模板来抽象:</p><pre><code>#include &lt;iostream&gt;
using namespace std;
template&lt;class T&gt;//����һ��ģ�壬����������ΪT
class Operation {
public:
    Operation (T a, T b):x(a),y(b){}
    T add(){
        return x+y;
    }
    T subtract(){
        return x-y;
    }
private:
    T x,y;
};
int main(){
    Operation &lt;int&gt; op_int(1,2);
    cout&lt;&lt;op_int.add()&lt;&lt;&quot; &quot;&lt;&lt;op_int.subtract()&lt;&lt;endl;//����3��-1
    Operation &lt;double&gt; op_double(1.2,2.3);
    cout&lt;&lt;op_double.add()&lt;&lt;&quot; &quot;&lt;&lt;op_double.subtract()&lt;&lt;endl;//����3.5��-1.1
    return 0;
}
➜  chapter02 ./0224
3 -1
3.5 -1.1
</code></pre><h4 id=虚函数纯虚函数>虚函数/纯虚函数</h4><p>虚函数可以使得基类指针访问派生类中的同名函数:<br>而纯虚函数则是因为：用基类本身生成对象不合情理，例如用动物作为基类来抽象具体的动物，而动物这个基类
本身是不能被实例化的。</p><p>析构函数不是虚函数时，容易引发内存泄漏:</p><pre><code>➜  chapter02 ./0231
Base::Base()
Derive::Derive()
Base::~Base()
➜  chapter02 cat 0231.cpp 
#include&lt;iostream&gt;
using namespace std;
class Base{
public:
    Base(){ std::cout&lt;&lt;&quot;Base::Base()&quot;&lt;&lt;std::endl; }
    ~Base(){ std::cout&lt;&lt;&quot;Base::~Base()&quot;&lt;&lt;std::endl; }
};
class Derive:public Base{
public:
    Derive(){ std::cout&lt;&lt;&quot;Derive::Derive()&quot;&lt;&lt;std::endl; }
    ~Derive(){ std::cout&lt;&lt;&quot;Derive::~Derive()&quot;&lt;&lt;std::endl; }
};
int main(){
    Base* pBase = new Derive(); 
    /*����base classed������Ŀ����Ϊ������&quot;ͨ��base class�ӿڴ���derived class����&quot;*/
    delete pBase;
    return 0;
}
</code></pre><p>这是由C++的定义指出的：如果一个派生类对象经由一个基类指针被删除，而该基类带有一个非虚析构函数，则会导致
派生类中的成分没被销毁。</p><p>所以，需要把析构函数定义为虚函数。</p><pre><code>➜  chapter02 ./0232
Base::Base()
Derive::Derive()
Derive::~Derive()
Base::~Base()
➜  chapter02 cat 0232.cpp 
#include&lt;iostream&gt;
using namespace std;
class Base{
public:
    Base(){ std::cout&lt;&lt;&quot;Base::Base()&quot;&lt;&lt;std::endl; }
    virtual ~Base(){ std::cout&lt;&lt;&quot;Base::~Base()&quot;&lt;&lt;std::endl; }
};

class Derive:public Base{
public:
    Derive(){ std::cout&lt;&lt;&quot;Derive::Derive()&quot;&lt;&lt;std::endl; }
    ~Derive(){ std::cout&lt;&lt;&quot;Derive::~Derive()&quot;&lt;&lt;std::endl; }
};

int main(){
    Base* pBase = new Derive();
    delete pBase;
    return 0;
}
</code></pre><h4 id=单例模式>单例模式</h4><p>理解：一台计算机上可以连好几台打印机，但是打印程序只能有一个，这里就可以通过单例模式来避免两个打印作业
被同时输出到打印机中。</p><pre><code>➜  chapter02 ./0233
s1=s2
➜  chapter02 cat 0233.cpp 
#include&lt;iostream&gt;
using namespace std;
class CSingleton{
private:
	CSingleton(){   //构造函数是私有的
	}
	static CSingleton *m_pInstance;
public:
	static CSingleton * GetInstance(){
        if(m_pInstance == NULL)  //判断是否是第一次调用
	        m_pInstance = new CSingleton();
	    return m_pInstance;
	}
};
CSingleton * CSingleton::m_pInstance=NULL;//初始化静态成员变量
int main(){
    CSingleton *s1= CSingleton::GetInstance();
    CSingleton *s2= CSingleton::GetInstance();
    if(s1==s2){
        cout&lt;&lt;&quot;s1=s2&quot;&lt;&lt;endl; 
    }
    return 0;
}
</code></pre><p>单例类的特点：</p><pre><code>1. 有指向唯一实例的静态指针m_pInstance，且为私有。   
2. 有一个公有函数用于获取唯一的实例。
3. 构造函数是私有的，不能在别处创建该类的实例.
</code></pre></div><div class=post><h1 class=post-title><a href=http://purplepalmdash.github.io/blog/2017/01/07/hugo-and-travisci-issue/>Hugo And TravisCI Issue</a></h1><span class=post-date>Jan 7, 2017<br><a class=a_cat href=http://purplepalmdash.github.io/categories/technology>Technology</a></span><h3 id=problem>Problem</h3><p>In this morning when I get up and try to write something in my blog, I found
the blog won&rsquo;t upate. In travisCI website I got something very strange like
following picture shows:</p><p><img src=/images/2017_01_07_10_29_39_562x249.jpg alt=/images/2017_01_07_10_29_39_562x249.jpg></p><p>Error info:</p><pre><code>Failed to normalize URL string. Returning in = &quot;/&quot;
</code></pre><h3 id=reason>Reason</h3><p>As discussed in this post:</p><p><a href=https://discuss.gohugo.io/t/started-getting-failed-to-normalize-url-string-returning-in/5034>https://discuss.gohugo.io/t/started-getting-failed-to-normalize-url-string-returning-in/5034</a></p><p>This is because hugo now holds its own dependencies using govendor, you could
view from its repository:</p><pre><code>$ cd $GOPATH
$ cd src/github.com/spf13/hugo 
$ ls -l vendor 
total 16
-rw-r--r-- 1 dash root 14793 Jan  3 11:23 vendor.json
</code></pre><h3 id=solution>Solution</h3><p>Using govendor for syncing the dependencies, the modified .travis.yml is
listed as following:</p><pre><code>install:
    - go get -u -v github.com/kardianos/govendor
    - go get -u -v github.com/spf13/hugo
    - cd $GOPATH/src/github.com/spf13/hugo &amp;&amp; govendor sync &amp;&amp; go install
  

script:
    - cd $HOME/gopath/src/github.com/purplepalmdash/purplepalmdash.github.io &amp;&amp; hugo
</code></pre><p>Save changes and commit it into github, the travis building will start again,
this time you won&rsquo;t failed.</p></div><div class=post><h1 class=post-title><a href=http://purplepalmdash.github.io/blog/2017/01/06/dockercloudreadingdigests/>DockerCloudReadingDigests</a></h1><span class=post-date>Jan 6, 2017<br><a class=a_cat href=http://purplepalmdash.github.io/categories/technology>Technology</a></span><h3 id=第一章>第一章</h3><p>Docker镜像准备:</p><pre><code>$ sudo docker pull redis
$ sudo docker pull django
$ sudo docker pull haproxy
$ sudo docker pull ubuntu
</code></pre><p>应用栈节点架构:</p><p>启动redis-master容器节点, 两个redis-slave容器节点启动时连接到redis-master上面,
两个app容器节点启动时连接到redis-master上面, haproxy容器结点启动时连接到两个app结点上面。</p><p>容器的启动顺序为：redis-master -> redis-slave -> APP -> HAProxy.</p><p>Redis Master:</p><pre><code>$ sudo docker run -it --name redis-master redis /bin/bash
root@4e4e597ffcb6:/data# 
</code></pre><p>Redis Slave1/Slave2:</p><pre><code>$ sudo docker run -it --name redis-slave1 --link redis-master:master redis /bin/bash
$ sudo docker run -it --name redis-slave2 --link redis-master:master redis /bin/bash
</code></pre><p>App1, App2:</p><pre><code>$ mkdir -p ~/Projects/Django/App1
$ mkdir -p ~/Projects/Django/App2
$ sudo docker run -it --name APP1 --link redis-master:db -v ~/Projects/Django/App1:/user/src/app django /bin/bash
$ sudo docker run -it --name APP2 --link redis-master:db -v ~/Projects/Django/App2:/user/src/app django /bin/bash
</code></pre><p>HAProxy:</p><pre><code>$ mkdir -p ~/Projects/HAProxy
$ sudo docker run -it --name HAProxy --link APP1:APP1 --link APP2:APP2 -p 6301:6301 -v ~/Projects/HAProxy:/tmp haproxy /bin/bash
</code></pre><p>检查source目录挂载:</p><pre><code>$ sudo docker ps | grep master
4e4e597ffcb6        redis                            &quot;docker-entrypoint.sh&quot;
43 minutes ago      Up 43 minutes       6379/tcp                 redis-master
$ sudo docker inspect 4e4e | grep Source
&quot;Source&quot;:
&quot;/var1/DockerRepo/docker/volumes/1dc31736abd411569cfbc51c6624125867883b44733f40113e2f918770843438/_data&quot;,
</code></pre><p>下载redis.conf文件:</p><pre><code>$ wget http://download.redis.io/redis-stable/redis.conf
$ cp redis.conf /var1/DockerRepo/docker/volumes/1dc31736abd411569cfbc51c6624125867883b44733f40113e2f918770843438/_data
</code></pre><p>修改redis.conf内容:</p><pre><code>bind 0.0.0.0
</code></pre><p>进入到容器后的操作:</p><pre><code># mkdir /var/lib/redis
# cd /data
# cp redis.conf /usr/local/bin
# cd /usr/local/bin
# redis-server redis.conf
</code></pre><p>Slave节点的配置:</p><pre><code># docker inspect f88a69ca2b1e | grep Source
                &quot;Source&quot;: &quot;/var1/DockerRepo/docker/volumes/6b211a6e469f4864a723dd7531f49674eeb9af9509ddcb75de8f18f4a677b85f/_data&quot;,
# cd /var1/DockerRepo/docker/volumes/6b211a6e469f4864a723dd7531f49674eeb9af9509ddcb75de8f18f4a677b85f/_data
# cp /home/dash/redis.conf  ./
# vim redis.conf 
slaveof master 6379
# docker inspect 14bbec8a900b | grep Source
                &quot;Source&quot;: &quot;/var1/DockerRepo/docker/volumes/a51e5a23a9b2e36350325aac6c533a48beb34d566b08773d48a2a3273c786d42/_data&quot;,
# cp redis.conf /var1/DockerRepo/docker/volumes/a51e5a23a9b2e36350325aac6c533a48beb34d566b08773d48a2a3273c786d42/_data
</code></pre><p>启动流程和Master一样。</p><p>Django配置, 注意要在我们映射的目录下:</p><pre><code>root@7243f0d5a231:/user/src/app# mkdir dockerweb
root@7243f0d5a231:/user/src/app# cd dockerweb/
root@7243f0d5a231:/user/src/app/dockerweb# cd redisweb/
root@7243f0d5a231:/user/src/app/dockerweb/redisweb# python manage.py startapp helloworld
</code></pre><p>修改django文件:</p><pre><code>$ pwd
/user/src/app
$ vim dockerweb/redisweb/helloworld/views.py 
from django.shortcuts import render
from django.http import HttpResponse

#Create your views here

import redis

def hello(request):
    str = redis.__file__
    str += &quot;&lt;br&gt;&quot;
    r = redis.Redis(host='db', port=6379, db=0)
    info = r.info()
    str += (&quot;Set Hi &lt;br&gt;&quot;)
    r.set('Hi', 'HelloWorld-APP1')
    str += (&quot;Get Hi: %s &lt;br&gt;&quot; % r.get('Hi'))
    str += (&quot;Redis Info: &lt;br&gt;&quot;)
    str += (&quot;Key: Info Value&quot;)
    for key in info:
        str += (&quot;%s: %s &lt;br&gt;&quot; % (key, info[key]))
    return HttpResponse(str)
</code></pre><p>添加helloworld程序到<code>INSTALLED_APPS</code>选项下:</p><pre><code>$ vim dockerweb/redisweb/redisweb/settings.py
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'helloworld',
]
</code></pre><p>修改urls.py:</p><pre><code>$ vim dockerweb/redisweb/redisweb/urls.py 
from django.conf.urls import url
from django.contrib import admin
from helloworld.views import hello

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^helloworld$', hello),
]
</code></pre><p>App1和App2的差别在于views.py里改掉这一行:</p><pre><code>    - r.set('Hi', 'HelloWorld-APP1')
    + r.set('Hi', 'HelloWorld-APP2')
</code></pre><p>之后运行:</p><pre><code># python manage.py makemigrations
# python manage.py migrate
# python manage.py createsuperuser
</code></pre><p>分别运行:</p><pre><code>#### APP1
# python manage.py runserver 0.0.0.0:8001
#### APP2
# python manage.py runserver 0.0.0.0:8002
</code></pre><p>HAProxy配置:</p><pre><code># cd ~/Projects/HAProxy
# vim haproxy.cfg
global 
  log 127.0.0.1 local0
  maxconn 4096
  chroot /usr/local/sbin
  daemon
  nbproc 4
  pidfile /usr/local/sbin/haproxy.pid

defaults
  log 127.0.0.1	local3
  mode http 
  option dontlognull 
  option redispatch
  retries 2
  maxconn 2000
  balance roundrobin
  timeout connect 5000ms
  timeout client 50000ms
  timeout server 50000ms

listen redis_proxy
  bind 0.0.0.0:6301
  stats enable
  stats uri /haproxy-stats
      server APP1 APP1:8001 check inter 2000 rise 2 fall 5 
      server APP2 APP2:8002 check inter 2000 rise 2 fall 5 
</code></pre><p>在haproxy容器里:</p><pre><code># cd /tmp
# cp haproxy.cfg /usr/local/sbin/
# cd /usr/local/sbin
# haproxy -f haproxy.cfg
</code></pre><p>现在验证:</p><p><code>http://127.0.0.1:6301/helloworld</code></p><p><img src=/images/2017_01_06_18_45_40_627x330.jpg alt=/images/2017_01_06_18_45_40_627x330.jpg></p><p><code>http://127.0.0.1:6301/haproxy-stats</code>:</p><p><img src=/images/2017_01_06_18_46_45_634x397.jpg alt=/images/2017_01_06_18_46_45_634x397.jpg></p></div><div class=post><h1 class=post-title><a href=http://purplepalmdash.github.io/blog/2017/01/03/%E8%BF%90%E8%A1%8Ck8s%E4%BE%8B%E7%A8%8B/>运行K8S例程</a></h1><span class=post-date>Jan 3, 2017<br><a class=a_cat href=http://purplepalmdash.github.io/categories/technology>Technology</a></span><h3 id=guestbook>GuestBook</h3><p>注意修改imagePullPolicy为<code>IfNotPresent</code>, 创建服务的步骤分别为:</p><pre><code>$ kubectl create -f redis-master-deployment.yaml
$ kubectl create -f redis-master-service.yaml
$ kubectl create -f frontend-deployment.yaml
$ kubectl create -f frontend-service.yaml
</code></pre><p>现在得到其运行状态:</p><pre><code>$ kubectl get pod
NAME                            READY     STATUS    RESTARTS   AGE
frontend-88237173-02dvl         1/1       Running   0          2h
frontend-88237173-r7g3v         1/1       Running   0          2h
frontend-88237173-vjbv5         1/1       Running   0          2h
redis-master-4154998525-f186t   1/1       Running   0          2h
redis-slave-132015689-3qh7b     1/1       Running   0          2h
redis-slave-132015689-hpw88     1/1       Running   0          2h
</code></pre><p>可以用proxy-forward直接访问某个pod中暴露出来的frontend服务:</p><pre><code>$ kubectl port-forward frontend-88237173-02dvl 9081:80
</code></pre><p>上述命令的意思是，将pod <code>frontend-88237173-02dvl</code>80端口的流量转发到
本地的9081端口，则可以通过访问<code>http://127.0.0.1:9081</code>来访问frontend.</p><p>或者，我们可以在service文件中指定服务类型为<code>NodePort</code>, 定义文件修改如下:</p><pre><code>spec:
  type: NodePort
  ports:
  - port: 80
    nodePort: 31080
</code></pre><p>服务创建以后，访问<code>http://CoreOS1IP:31080</code>则可访问到guestbook前端页面，三个CoreOS
节点的31080端口均可提供前端页面访问。</p></div><div class=post><h1 class=post-title><a href=http://purplepalmdash.github.io/blog/2017/01/03/myreadingbooks/>MyReadingBooks</a></h1><span class=post-date>Jan 3, 2017<br><a class=a_cat href=http://purplepalmdash.github.io/categories/technology>Technology</a></span><h3 id=文学类>文学类</h3><h4 id=1>1</h4><p>《流亡中的自在》达lai喇嘛著.<br>心得：<br>从另一个角度看待西藏问题，当事人很难得的回忆录。<br>阅读时间： 2017.1.1</p><h4 id=2>2</h4><p>《五代十国》 朱长孝著.<br>心得：<br>演艺类小说，讲述五代十国的风云人物/事件。<br>阅读时间： 2017.1.2 ~</p><h4 id=3>3</h4><p>《鲸鱼女孩 池塘男孩》痞子蔡著.<br>心得：<br>台湾网络文学，<code>小确幸</code>的典型文章，读起来很温馨。<br>阅读时间： 2017.1.1</p><h4 id=4>4</h4><p>《窗边的小豆豆》 (日本)黑柳彻子著.<br>心得：<br>幼儿教育类作品，一个叫豆豆的淘气小女孩，如何在一所尊重儿童个性的幼儿园里愉快成长的故事，很值得当代的
中国父母们看看。<br>阅读时间： 2017.1.1</p><h4 id=5>5</h4><p>《北极风情画》卜乃夫著.<br>心得：<br>40年代作品，言情作品，一个在东北参加马占山抗日的南韩青年随部队流亡到苏联后，与一位波兰少女的爱情故事。<br>阅读时间: 2017.1.1</p><h4 id=6>6</h4><p>《人类的故事》(美) 房龙著, 白马译，中国文联出版社.<br>心得：<br>故事真是娓娓道来，书中的插图也很有想象力，这本书质感很好，拿在手里就不想放。<br>之前对欧洲中世纪的历史不是很了解，看完这本书以后了解了基督教三大派系的起源和发展，了解了原来俄罗斯
的起源在于东罗马帝国、沙皇的本意是凯撒等等…………作者写作的时候是20世纪初，当时能有如此宏观的视角，真是让人佩服。</p><p>后续我想继续找到他写的《圣经的故事》《宽容》等作品.<br>阅读时间： 2017.1.3～2017.1.6</p><h4 id=7>7</h4><p>《草房子》<br>心得：
已经是第二次看这本书了，第一次是在nook上，依然兴趣盎然。好的作品就是这样，值得回味。适合儿童、童心未泯的成人阅读。
关于苏北的一些习俗，写得很好。<br>阅读时间： 2017.1.8~ 2017.1.10</p><h4 id=8>8</h4><p>《欲乐园》（日）渡边淳一<br>心得：<br>草根医生与富家姑娘、穷护士之间的一段孽缘。以学历论英雄之狭隘被讽刺得很深刻。<br>阅读时间: 2017.02.09晚</p><h3 id=技术类>技术类</h3><h4 id=1-1>1</h4><p>《实用数据分析》 (美) Hector Cuesta著.<br>心得：<br>可以直接上手用来把玩数据。
阅读时间: 2017.1.1 ~ 2017.1.3</p><h4 id=2-1>2</h4><p>《Docker基础与实战》(韩) 李在弘著.<br>心得：<br>比较基础，直接翻阅即可。里头的很多例子可以借鉴一下，适合初学者用。第8章的例子不错。但是怎么说呢？这本书文笔太罗嗦，六块九的
东西写成了69块钱。从图书馆借阅就好.<br>阅读时间: 2017.02.22~ 2017.02.23</p><h4 id=3-1>3</h4><p>《开源云平台CloudStack实战》(中) 鲍亮 叶宏著.<br>心得：<br>泛泛之书，感觉就是西安交大的一个副教授带着手下的几个研究生写的一本关于Cloudstack的书，作为阅读物就好，而且各种代码都没法
下载，不推荐购买。而且这么烂的书敢卖69块钱，真是想钱想疯了.<br>阅读时间: 2017.02.21</p></div><ul class=pagination><li class=page-item><a href=/ class=page-link aria-label=First><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/page/107/ class=page-link aria-label=Previous><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a class=page-link href=/>1</a></li><li class=page-item><a class=page-link href=/page/2/>2</a></li><li class=page-item><a class=page-link href=/page/3/>3</a></li><li class="page-item disabled"><span aria-hidden=true>&nbsp;&mldr;&nbsp;</span></li><li class=page-item><a class=page-link href=/page/107/>107</a></li><li class="page-item active"><a class=page-link href=/page/108/>108</a></li><li class=page-item><a class=page-link href=/page/109/>109</a></li><li class="page-item disabled"><span aria-hidden=true>&nbsp;&mldr;&nbsp;</span></li><li class=page-item><a class=page-link href=/page/246/>246</a></li><li class=page-item><a href=/page/109/ class=page-link aria-label=Next><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/page/246/ class=page-link aria-label=Last><span aria-hidden=true>&#187;&#187;</span></a></li></ul></div></div><script src=http://purplepalmdash.github.io/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>