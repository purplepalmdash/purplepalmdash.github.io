<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en lang=en-us><head><meta name=generator content="Hugo 0.64.0"><link href=http://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><title>Dash &#183; Dash</title><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css><link rel=stylesheet href="https://purplepalmdash.github.io/css/poole.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/hyde.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/poole-overrides.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/hyde-overrides.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/hyde-a.css?ref=abc124"><link rel=stylesheet href="https://purplepalmdash.github.io/css/custom-additions.css?ref=abc124"><link rel=stylesheet href=https://purplepalmdash.github.io/css/highlight/googlecode.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.3.0/css/font-awesome.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/docco.min.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/1.10.2/jquery.min.js></script><script type=text/javascript src=/js/html2canvas.js></script><script type=text/javascript>function genPostShot(){var rightNow=new Date();var imageName=rightNow.toISOString().slice(0,16).replace(/(-)|(:)|(T)/g,"");imageName+='.jpg'
html2canvas(document.getElementsByClassName('post'),{background:'#FFFFFF',onrendered:function(canvas){$('#test').attr('href',canvas.toDataURL("image/jpeg"));$('#test').attr('download',imageName);$('#test')[0].click();}});};</script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><link rel=apple-touch-icon-precomposed sizes=144x144 href="http://purplepalmdash.github.io/touch-icon-144-precomposed.png?ref=abc124"><link href="http://purplepalmdash.github.io/favicon.png?ref=abc124" rel=icon><link href=%7balternate%20%7bRSS%20application/rss+xml%20%20index%20alternate%20%20false%20false%20true%20false%20false%200%7d%20/index.xml%20http://purplepalmdash.github.io/index.xml%7d rel=alternate type=application/rss+xml title="Dash &#183; Dash"><meta name=description content><meta name=keywords content="unix,virtualization,embedded,linux"></head><body class=theme-base-0c><div class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><img src=http://purplepalmdash.github.io/images/mylogo.jpeg alt=gravatar><h1><a href=http://purplepalmdash.github.io/>很惭愧，就做了一点微小的工作</a></h1><a href=http://purplepalmdash.github.io/><p>Dash</p></a></div><ul class=sidebar-nav><li class=sidebar-nav-item><a href=http://purplepalmdash.github.io/post/>All Posts</a></li><li class=sidebar-nav-item><a href=http://purplepalmdash.github.io/categories/technology/>Technology</a></li><li class=sidebar-nav-item><a href=http://purplepalmdash.github.io/categories/life/>Life</a></li><li class=sidebar-nav-item><a href=http://purplepalmdash.github.io/categories/linuxtips/>LinuxTips</a></li></ul><ul class=sidebar-nav><li class=sidebar-nav-item><a href=https://github.com/purplepalmdash><i class="fa fa-github-square fa-3x"></i></a><a href=https://cn.linkedin.com/in/yang-feipeng-1b909319><i class="fa fa-linkedin-square fa-3x"></i></a><a href=https://plus.google.com/u/0/106572959364703833986><i class="fa fa-google-plus-square fa-3x"></i></a><a href=https://www.facebook.com/yang.feipeng><i class="fa fa-facebook-square fa-3x"></i></a><a href=https://twitter.com/dashwillfly><i class="fa fa-twitter-square fa-3x"></i></a></li></ul></div></div><div class="content container"><div class=posts><div class=post><h1 class=post-title><a href=http://purplepalmdash.github.io/2013/07/10/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-3/>用Qemu和GNU编译链研究ARM汇编(3)</a></h1><span class=post-date>Jul 10, 2013<br><a class=a_cat href=http://purplepalmdash.github.io/categories/technology>Technology</a></span><p>在多个文件构成的程序中，源文件首先被编译成多个对象(object)文件(.o文件),
然后交由链接器生成最终的可执行文件，如下图所示：</p><pre><code>{% img img /images/linker.png %}
</code></pre><p>在组建可执行文件时，链接器主要完成下列操作:</p><ul><li>解析符号</li><li>重定位</li></ul><p>1. 符号解析</p><p>在编译单个文件组成的程序时，所有标号的解析都可以由汇编器替代为对应的地址。而在多文件组成的程序中，如果有储存在其他文件中的符号引用，汇编器会将其标识为"unresolved&rdquo;(未解析).当对象文件被传递给链接器时，链接器从这些文件中决定对应的值，并把code中的unresolved的值替代为正确的值。</p><p>我们用上一节的求和函数来演示链接器是如何进行符号解析的。
这两个文件汇编后，会在链接时被检查未被解析的引用。</p><pre><code>main.s
        .text
        b start                 @ Skip over the data
arr:    .byte 10, 20, 25        @ Read-only array of bytes
eoa:                            @ Address of end of array + 1

        .align
start:
        ldr   r0, =arr          @ r0 = &amp;arr
        ldr   r1, =eoa          @ r1 = &amp;eoa

        bl    sum               @ Invoke the sum subroutine

stop:   b stop
</code></pre><p>more:</p><pre><code>sum-sub.s
        @ Args
        @ r0: Start address of array
        @ r1: End address of array
        @
        @ Result
        @ r3: Sum of Array

        .global sum

sum:    mov   r3, #0            @ r3 = 0
loop:   ldrb  r2, [r0], #1      @ r2 = *r0++    ; Get array element
        add   r3, r2, r3        @ r3 += r2      ; Calculate sum
        cmp   r0, r1            @ if (r0 != r1) ; Check if hit end-of-array
        bne   loop              @    goto loop  ; Loop
        mov   pc, lr            @ pc = lr       ; Return when done
</code></pre><p>查看.o文件符号信息：</p><pre><code>	$ arm-none-eabi-nm main.o
	00000004 t arr
	00000007 t eoa
	00000008 t start
	00000014 t stop
	         U sum
	$ arm-none-eabi-nm sum-sub.o 
	00000004 t loop
	00000000 T sum
</code></pre><p>t代表符号已经被定义了， 而u则代表符号未被定义。大写字母表示该符号是全局变量。</p><p>从上面的输出结果看，sum是被定义在sum-sub.o的全局变量，而该变量在main.o中未被解析到。当linker被调用时，符号引用将被解析到，对应的可执行文件将被生成。</p><p>总结： as程序负责把.s文件编译成object文件，而生成最终的可执行文件时，ld负责把未被定位的符号定位到实际的库函数所在的位置。</p><p>2. 重定位.</p><p>重定位用于改变已经分配给标号的地址。它包括将所有符号引用映射到新分配的内存地址。</p><p>合并段后的符号列表情况，可以对比于上面的main.o和sum-sub.o来看：</p><pre><code>	$ arm-none-eabi-ld -Ttext=0x0 -o sum.elf main.o sum-sub.o
	arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 00000000
	$ arm-none-eabi-nm sum.elf
	00000004 t arr
	00008038 T __bss_end__
	00008038 T _bss_end__
	00008038 T __bss_start
	00008038 T __bss_start__
	00008038 T __data_start
	00008038 T _edata
	00008038 T _end
	00008038 T __end__
	00000007 t eoa
	00000024 t loop
	00080000 T _stack
	00000008 t start
	         U _start
	00000014 t stop
	00000020 T sum
</code></pre><p>可以看到stop后面的sum已经被定位好了(之前是main.o中的U标记)，而loop则相应延后，被定位到了再往后的00000024。</p><p>地址的变更： loop原本地址为00000004, 现在是00000024, 而sum原本为0x00000000，现在为00000020, 这是因为sum-sub.o中的.text和main.o中的.text部分一起组成了sum.elf中的.text部分。</p><p>整体移动某个段到指定内存位置, 注意在-Ttext中我们增加的0x100的偏移量，使得地址对比于上面的结果整体上移了0x100:</p><pre><code>	$ arm-none-eabi-ld -Ttext=0x100 -o sum100.elf main.o sum-sub.o
	arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 00000100
	$ arm-none-eabi-nm sum100.elf 
	00000104 t arr
	00008138 T __bss_end__
	00008138 T _bss_end__
	00008138 T __bss_start
	00008138 T __bss_start__
	00008138 T __data_start
	00008138 T _edata
	00008138 T _end
	00008138 T __end__
	00000107 t eoa
	00000124 t loop
	00080000 T _stack
	00000108 t start
	         U _start
	00000114 t stop
	00000120 T sum
</code></pre><p>3. 重定位.data到RAM中。</p><p>我们可以通过撰写链接脚本，将程序的.data段放置在RAM中。这也是通常嵌入式系统所谓bootloader干的活儿，从Flash中加载启动代码到RAM中而后执行。</p><p>例程从RAM中加载两个数值，将两者相加而后将结果写回RAM，两个值和结果都放置在.data部分。</p><p>代码：</p><pre><code>        .data
val1:   .4byte 10               @ First number
val2:   .4byte 30               @ Second number
result: .4byte 0                @ 4 byte space for result

        .text
        .align
start:
        ldr   r0, =val1         @ r0 = &amp;val1
        ldr   r1, =val2         @ r1 = &amp;val2

        ldr   r2, [r0]          @ r2 = *r0
        ldr   r3, [r1]          @ r3 = *r1

        add   r4, r2, r3        @ r4 = r2 + r3

        ldr   r0, =result       @ r0 = &amp;result
        str   r4, [r0]          @ *r0 = r4

stop:   b stop
</code></pre><p>链接脚本：</p><pre><code>SECTIONS {
        . = 0x00000000;
        .text : { * (.text); }

        . = 0xA0000000;
        .data : { * (.data); }
}
</code></pre><p>从connex的内存布局来看，内存地址为0xa000_0000到0xa400_0000，因而A0000000刚好在内存中。</p><p>查看链接后的内存符号地址:</p><pre><code>	$ arm-none-eabi-as -o sum.o sum.s
	$ arm-none-eabi-ld -T sum_link.ld -o sum.elf sum.o 
	$ arm-none-eabi-nm -n sum.elf 
	00000000 t start
	0000001c t stop
	a0000000 d val1
	a0000004 d val2
	a0000008 d result
</code></pre><p>这样就完了？NO！！！！！！！！因为：RAM is Volatile! 内存是易变的！</p><p>RAM是易失性介质，怎可保证每次加电时就有代码洗干净PP在等着被运行？嵌入式系统里必然有非易失性存储，所有的代码和数据在加电前都需要放在这些非易失性存储介质中，例如在FLASH中。这样在加电后我们就可以利用一段启动代码把代码从FLASH搬到RAM中。</p><p>从这个设计思路出发，我们需要程序的.data有两个地址，一个是加载地址，另一个是运行地址。
这就是常说的：LMA(Load Memory Address) VS VMA(Virtual Memory Address)。</p><p>上面的代码需要做两个修改:</p><ol><li>需要在.data中指定load地址和运行地址</li><li>需要写一段代码用于将数据从FLASH读取到RAM中, 从存储地址到运行地址。</li></ol><pre><code>SECTIONS {
        . = 0x00000000;
        .text : { * (.text); }
        etext = .;

        . = 0xA0000000;
        .data : AT (etext) { * (.data); }
}
</code></pre><p>etext包含了FLASH中放置完地址后的空白地址，记住这个地址以便在接下来将这个数值传送给.data部分，以便程序将.data部分从FLASH拷贝到RAM中。etext只是符号表中的一个，本身并不占据任何内存(可以回去翻上一篇日志)。</p><p>关于AT关键字: 它指定了.data部分的加载地址，一个地址或符号被传递给AT关键字，以便它从该地址拷贝数据。 在这里，我们传递etext符号给AT。</p><p>要把代码从FLASH拷贝到RAM中，下列信息需要被提供：</p><ol><li>Flash中数据地址(flash_sdata)</li><li>RAM中数据地址(ram_sdata)</li><li>.data部分大小(data_size)</li></ol><p>拷贝代码：</p><pre><code>        ldr   r0, =flash_sdata
        ldr   r1, =ram_sdata
        ldr   r2, =data_size

copy:
        ldrb  r4, [r0], #1
        strb  r4, [r1], #1
        subs  r2, r2, #1
        bne   copy
</code></pre><p>由此，我们需要在链接脚本中生成这三个数值：</p><pre><code>SECTIONS {
        . = 0x00000000;
        .text : {
              * (.text);
        }
        flash_sdata = .;

        . = 0xA0000000;
        ram_sdata = .;
        .data : AT (flash_sdata) {* (.data); }
        ram_edata = .;
        data_size = ram_edata - ram_sdata;
}
</code></pre><p>ram_sdata为ram中数据开始地址，而ram_edata为结束地址，两者相减则为数据块大小。</p><p>改变后的带有copy数据的代码：</p><pre><code>        .data
val1:   .4byte 10               @ First number
val2:   .4byte 30               @ Second number
result: .space 4                @ 1 byte space for result

        .text

        ;; Copy data to RAM.
start:
        ldr   r0, =flash_sdata
        ldr   r1, =ram_sdata
        ldr   r2, =data_size

copy:
        ldrb  r4, [r0], #1
        strb  r4, [r1], #1
        subs  r2, r2, #1
        bne   copy

        ;; Add and store result.
        ldr   r0, =val1         @ r0 = &amp;val1
        ldr   r1, =val2         @ r1 = &amp;val2

        ldr   r2, [r0]          @ r2 = *r0
        ldr   r3, [r1]          @ r3 = *r1

        add   r4, r2, r3        @ r4 = r2 + r3

        ldr   r0, =result       @ r0 = &amp;result
        str   r4, [r0]          @ *r0 = r4

stop:   b stop
</code></pre><p>使用修改过的final_sum_ram.s和link脚本编译，并生成flash.bin后，就可以在qemu-system-arm中验证结果了。</p><pre><code>$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
QEMU 1.4.2 monitor - type 'help' for more information
(qemu) info registers
R00=a0000008 R01=a0000004 R02=0000000a R03=0000001e
R04=00000028 R05=00000000 R06=00000000 R07=00000000
R08=00000000 R09=00000000 R10=00000000 R11=00000000
R12=00000000 R13=00000000 R14=00000000 R15=00000038
PSR=600001d3 -ZC- A svc32
FPSCR: 00000000

(qemu) xp /4dw 0xA0000000
00000000a0000000:         10         30         40          0
</code></pre><p>R04包含了我们相加后的结果, 为0x28=40, R02/R03则分别为操作数10/30. 而通过显示0xA0000000也显示了内存中的值分别为val1/val2/result的值。</p><p>接下来的章节中，我们将讲到C代码入口。</p></div><div class=post><h1 class=post-title><a href=http://purplepalmdash.github.io/2013/07/09/yong-qemuhe-gnubian-yi-lian-yan-jiu-armhui-bian-1/>用Qemu和GNU编译链研究ARM汇编(1)</a></h1><span class=post-date>Jul 9, 2013<br><a class=a_cat href=http://purplepalmdash.github.io/categories/technology>Technology</a></span><p>1. 汇编程序代码格式</p><p>汇编代码由一系列的声明所组成，每行一个。每条声明由下列格式组成：</p><pre><code>	label(标签):	instruction	@comment(注释)
</code></pre><p>说明：</p><ul><li>label:
标签的引入使得在内存中查询指令地址变得很方便，标签可以在任意一个内存地址使用，
例如分支指令中就可以用到标签, 标签可以包括字母、数字_和$符号。</li><li>注释：
注释内容必须在@符号之后</li><li>指令:
指令可以是ARM指令集或是汇编器指令，汇编器指令是需要传递给汇编器的命令，总是以.开头。</li></ul><p>2. 一个简单的汇编语言文件:</p><pre><code>        .text
start:                       @ Label, not really required
        mov   r0, #5         @ Load register r0 with the value 5
        mov   r1, #4         @ Load register r1 with the value 4
        add   r2, r1, r0     @ Add r0 and r1 and store in r2

stop:   b stop               @ Infinite loop to stop execution
</code></pre><p>上面代码的意思是，把立即数5载入到寄存器r0, 4载入到r1,
以r1和r0相加的结果填充r2.</p><p>.text是汇编器指令，用于告知汇编器需要把代码组装到code段,而不是.data段。有关section的概念在后面将被讲到。</p><p>3. 编译二进制文件</p><p>GNU的汇编器名字叫as， 用下列命令将源文件编译成.o文件</p><pre><code>	$ arm-none-eabi-as -o add.o add.s
</code></pre><p>链接器的名字叫ld，用下列命令可以将二进制文件链接成elf文件</p><pre><code>	$ arm-none-eabi-ld -Ttext=0x0 -o add.elf add.o
</code></pre><p>-Ttext指明需要分配给label的地址,
这条指令告诉链接器从地址0x0开始装载指令。我们可以用nm来查看具体的地址分配信息。</p><pre><code>	$ arm-none-eabi-nm add.elf 
	00008010 T __bss_end__
	00008010 T _bss_end__
	00008010 T __bss_start
	00008010 T __bss_start__
	00008010 T __data_start
	00008010 T _edata
	00008010 T _end
	00008010 T __end__
	00080000 T _stack
	00000000 t start
	         U _start
	0000000c t stop
</code></pre><p>start和stop之间由0c个字节，因为stop是在start开始后三条指令，
每条指令的长度为4个Byte，3*4=12=0xc</p><p>更改链接的参数将得到不同的地址分配。</p><pre><code>	$ arm-none-eabi-ld -Ttext=0x20000000 -o add.elf add.o
	arm-none-eabi-ld: warning: cannot find entry symbol _start; defaulting to 20000000
	$ arm-none-eabi-nm add.elf
	20008010 T __bss_end__
	20008010 T _bss_end__
	20008010 T __bss_start
	20008010 T __bss_start__
	20008010 T __data_start
	20008010 T _edata
	20008010 T _end
	20008010 T __end__
	00080000 T _stack
	20000000 t start
	         U _start
	2000000c t stop
</code></pre><p>ld得到的文件一般是ELF文件，在有操作系统的时候ELF可以工作的很好，但是我们将在裸机模式下(Bare
Metal)运行此程序， 因此需要将文件类型转化为更简单的binary类型。</p><p>GNU编译链的objcopy可以完成不同可执行文件之间的转换：</p><pre><code>	$ arm-none-eabi-objcopy -O binary add.elf add.bin
	$ file add.bin
	add.bin: Hitachi SH big-endian COFF
</code></pre><p>4. 在Qemu中执行二进制文件。</p><p>我们将使用connex开发板来模拟运行此程序，它把16MB的Flash放在地址0x0，而通常arm处理器重启时都会执行0x0处的代码。
因而我们需要把add.bin写入到16MB Flash文件的头部。</p><p>首先创建一个空的16MB Flash文件</p><pre><code>	$ dd if=/dev/zero of=flash.bin bs=4k count=4k
	4096+0 records in
	4096+0 records out
	16777216 bytes (17 MB) copied, 0.0153106 s, 1.1 GB/s
</code></pre><p>而后，使用下列命令将add.bin放到Flash头部</p><pre><code>	$ dd if=add.bin of=flash.bin bs=4K conv=notrunc
	0+1 records in
	0+1 records out
	16 bytes (16 B) copied, 0.00011154 s, 143 kB/s
</code></pre><p>add.bin大小刚好为16B, notrunc参数代表no truncated，意思是直接覆盖掉原有内容。</p><p>用下列命令执行此改动后的flash文件:</p><pre><code>	$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null
	QEMU 1.4.2 monitor - type 'help' for more information
</code></pre><p>-M connex 指定connex机器， -pflash指定flash.bin代替flash闪存。</p><p>-pflash file use &lsquo;file&rsquo; as a parallel flash image 并行flash镜像</p><p>-serial /dev/null 将connex的串口输出重定向到/dev/null</p><p>查看寄存器信息：</p><pre><code>	(qemu) info registers
	R00=00000005 R01=00000004 R02=00000009 R03=00000000
	R04=00000000 R05=00000000 R06=00000000 R07=00000000
	R08=00000000 R09=00000000 R10=00000000 R11=00000000
	R12=00000000 R13=00000000 R14=00000000 R15=0000000c
	PSR=400001d3 -Z-- A svc32
	FPSCR: 00000000
</code></pre><p>R02的值正是计算后的结果4+5=9.
R15=0000000c 猜测应该为指令寄存器，指向stop(0xc)</p><p>5. 更多的查看命令:</p><pre><code>help	 List available commands
quit	 Quits the emulator
xp /fmt addr	 Physical memory dump from addr
system_reset	 Reset the system.
</code></pre><pre><code>	(qemu) help xp
	xp /fmt addr -- physical memory dump starting at 'addr'
	(qemu) xp /4iw 0x0
	0x00000000:  e3a00005      mov	r0, #5	; 0x5
	0x00000004:  e3a01004      mov	r1, #4	; 0x4
	0x00000008:  e0812000      add	r2, r1, r0
	0x0000000c:  eafffffe      b	0xc
</code></pre><p>4: 4 个条目被显示, i表示打印出指令，即内建的反汇编，
w表明条目的大小为32个bit，即一个全字。</p></div><div class=post><h1 class=post-title><a href=http://purplepalmdash.github.io/2013/07/08/zai-qemushang-yun-xing-raspberry-pijing-xiang/>在Qemu上运行Raspberry PI镜像</a></h1><span class=post-date>Jul 8, 2013<br><a class=a_cat href=http://purplepalmdash.github.io/categories/technology>Technology</a></span><p>1. 下载和准备镜像文件</p><pre><code>	$ wget http://downloads.raspberrypi.org/images/raspbian/2013-05-25-wheezy-raspbian/2013-05-25-wheezy-raspbian.zip
	$ unzip 2013-05-25-wheezy-raspbian.zip
</code></pre><p>2. 查看镜像文件分区信息</p><pre><code>	$ fdisk -l 2013-05-25-wheezy-raspbian.img 
	Disk 2013-05-25-wheezy-raspbian.img: 1939 MB, 1939865600 bytes, 3788800 sectors
	Units = sectors of 1 * 512 = 512 bytes
	Sector size (logical/physical): 512 bytes / 512 bytes
	I/O size (minimum/optimal): 512 bytes / 512 bytes
	Disk label type: dos
	Disk identifier: 0x000c7b31
	
	                         Device Boot      Start         End      Blocks   Id
	System
	2013-05-25-wheezy-raspbian.img1            8192      122879       57344    c 	W95 FAT32 (LBA)
	2013-05-25-wheezy-raspbian.img2          122880     3788799     1832960   83	Linux
</code></pre><p>从上面可以看到，根文件分区的地址偏移为512*122880=62914560</p><p>3. 更改根分区文件里preload信息:</p><pre><code>	$ sudo mount ./2013-05-25-wheezy-raspbian.img -o offset=62914560 /mnt3
	$ sudo vim /mnt3/etc/ld.so.preload 
	#注释掉这一行，否则在qemu启动完系统后将自动提示配置rpi而造成系统无法登陆
	#/usr/lib/arm-linux-gnueabihf/libcofi_rpi.so
	$ sudo umount /mnt3
</code></pre><p>4. 用qemu-system-arm启动raspberrypi镜像</p><pre><code>	$ qemu-system-arm -kernel kernel-qemu -cpu arm1176 -m 256 -M versatilepb \
	-no-reboot -serial stdio -append &quot;root=/dev/sda2 panic=1&quot; -hda \
	./2013-05-25-wheezy-raspbian.img 
</code></pre><p>系统将启动到一个root登陆的无需密码的shell中，运行下列命令以修复文件系统:</p><pre><code>	$ fsck /dev/sda2
	$ shutdown -r now
</code></pre><p>再次启动完毕后的登陆用户名和密码如下，接下来就等同于原机操作了。</p><pre><code>	Login as pi
	Password raspberry
</code></pre><p>5. ArchLinux on RaspberryPI</p><p>基本步骤也是一样，挂在第2块分区后，需要更改etc/fstab做下列修改：</p><pre><code>	# &lt;file system&gt;        &lt;dir&gt;         &lt;type&gt;    &lt;options&gt;          &lt;dump&gt; &lt;pass&gt;
	/dev/sda1	  /boot           vfat    defaults        0       0
	/dev/sda2	  /		auto    defaults        0       0
</code></pre><p>之后挂载命令一样。</p></div><div class=post><h1 class=post-title><a href=http://purplepalmdash.github.io/2013/07/08/yong-qemumo-ni-arm-1/>用Qemu模拟ARM(1)</a></h1><span class=post-date>Jul 8, 2013<br><a class=a_cat href=http://purplepalmdash.github.io/categories/technology>Technology</a></span><p>前面已经安装并配置了编译链和qemu，现在可以用qemu来模拟arm平台了。</p><p>1. Hello, Qemu!</p><p>输入下面的代码:</p><pre><code>#include&lt;stdio.h&gt;
int main()
{
    printf(&quot;Hello, Qemu!\n&quot;);
    return 0;
}
</code></pre><p>编译并运行:</p><pre><code>	$ arm-none-linux-gnueabi-gcc -o hello hello.c -static
	$ qemu-arm ./hello
	$ file hello
	hello: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV), \
	 statically linked, for GNU/Linux 2.6.16, not stripped
</code></pre><p>不加-static变量的话，运行时则需要使用-L选项链接到相应的运行库</p><pre><code>	$ qemu-arm -L /home/Trusty/CodeSourcery/\
	Sourcery_CodeBench_Lite_for_ARM_GNU_Linux/\
	arm-none-linux-gnueabi/libc/  ./hello_1 
	Hello, Qemu!
	$ file hello_1
	hello_1: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV),\
	 dynamically linked (uses shared libs), for GNU/Linux 2.6.16, not stripped
</code></pre><p>动态编译和静态编译生成的文件大小差别：</p><pre><code>	$ ls -l -h
	total 656K
	-rwxr-xr-x 1 Trusty root 640K Jul  7 18:46 hello
	-rwxr-xr-x 1 Trusty root 6.6K Jul  7 18:48 hello_1
</code></pre><p>###小插曲1：</p><p>系统里安装了两套编译链arm-none-eabi-和arm-none-linux-eabi-,很容易让人混淆，可参考编译链的命名规则：</p><p>arch(架构)-vendor(厂商名)-(os(操作系统名)-)abi(Application Binary
Interface，应用程序二进制接口)</p><p>举例说明：</p><ul><li>x86_64-w64-mingw32 = x86_64 &ldquo;arch"字段 (=AMD64), w64 (=mingw-w64
是"vendor"字段), mingw32 (=GCC所见的win32 API)</li><li>i686-unknown-linux-gnu = 32位 GNU/linux编译链</li><li>arm-none-linux-gnueabi = ARM 架构, 无vendor字段, linux 系统, gnueabi ABI.</li><li>arm-none-eabi = ARM架构, 无厂商, eabi ABI(embedded abi)</li></ul><p>两种编译链的主要区别在于库的差别，前者没有后者的库多，后者主要用于在有操作系统的时候编译APP用的。前者不包括标准输入输出库在内的很多C标准库，适合于做面向硬件的类似单片机那样的开发。因而如果采用arm-none-eabi-gcc来编译hello.c会出现链接错误。</p><p>###小插曲2：</p><p>qemu-arm和qemu-system-arm的区别：</p><ul><li>qemu-arm是用户模式的模拟器(更精确的表述应该是系统调用模拟器)，而qemu-system-arm则是系统模拟器，它可以模拟出整个机器并运行操作系统</li><li>qemu-arm仅可用来运行二进制文件，因此你可以交叉编译完例如hello
world之类的程序然后交给qemu-arm来运行，简单而高效。而qemu-system-arm则需要你把hello
world程序下载到客户机操作系统能访问到的硬盘里才能运行。</li></ul><p>2. 使用qemu-system-arm运行Linux内核</p><p>从www.kernel.org下载最新内核,而后解压</p><pre><code>	$ tar xJf linux-3.10.tar.xz
	$ cd linux-3.10
	$ make ARCH=arm versatile_defconfig
	$ make menuconfig ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi-
</code></pre><p>上面的命令指定内核架构为arm，交叉编译链为arm-none-linux-gnueabi,
需要在make menuconfig弹出的窗口中选择到 “Kernel Features”, 激活“Use the ARM
EABI to compile the kernel”,
如果不激活这个选项的话，内核将无法加载接下来要制作的initramfs。</p><p>如果需要在u-boot上加载内核，就要编译为uImage的格式，uImage通过mkimage程序来压缩的，ArchLinux的yaourt仓库里可以找到这个包：</p><pre><code>	$ yaourt -S mkimage
</code></pre><p>安装好mkimage后，开始编译内核，因为CPU有4核，所以开启了-j8选项以加速编译:</p><pre><code>	$ make ARCH=arm CROSS_COMPILE=arm-none-linux-gnueabi- all -j8 uImage 
</code></pre><p>接下来我们可以在qemu-system-arm中测试我们的内核了</p><pre><code>	$ qemu-system-arm -M versatilepb -m 128M -kernel ./arch/arm/boot/uImage
</code></pre><p>在弹出的窗口中可以内核运行到了kernel
panic状态，这是因为内核无法加载root镜像的缘故，我们将制作一个最简单的hello
world的文件系统，告知kernel运行之。</p><pre><code>#include &lt;stdio.h&gt;
 
void main() {
	  printf(&quot;Hello World!\n&quot;);
	  while(1);
}
</code></pre><p>编译并制作启动镜像:</p><pre><code>	$ arm-none-linux-gnueabi-gcc -o init init.c -static
	$ echo init |cpio -o --format=newc &gt; initramfs
	1280 blocks
	$ file initramfs 
	initramfs: ASCII cpio archive (SVR4 with no CRC)
</code></pre><p>接下来我们回到编译目录下执行：</p><pre><code>	$ qemu-system-arm -M versatilepb -kernel ./arch/arm/boot/uImage  -initrd
	../initramfs -serial stdio -append &quot;console=tty1&quot;
</code></pre><p>这时候可以看到，kernel运行并在Qemu自带的终端里打印出"Hello World!"。</p><p>如果我们改变console变量为ttyAMA0, 将在启动qemu-system-arm的本终端上打印出qemu的输出。</p></div><div class=post><h1 class=post-title><a href=http://purplepalmdash.github.io/2013/07/08/yong-qemumo-ni-arm-2/>用Qemu模拟ARM(2)</a></h1><span class=post-date>Jul 8, 2013<br><a class=a_cat href=http://purplepalmdash.github.io/categories/technology>Technology</a></span><p>1. 关于Bootloader:</p><p>(引导程序)位于电脑或其他计算机应用上，是指引导操作系统启动的程序。引导程序启动方式和程序视应用机型种类而不同。例如在普通的个人电脑上，引导程序通常分为两部分：第一阶段引导程序位于主引导记录（MBR），用以引导位于某个分区上的第二阶段引导程序，如NTLDR、GNU
GRUB等。</p><p>嵌入式系统中常见的Bootloader主要有以下几种:</p><ul><li>Das U-Boot
是一个主要用于嵌入式系统的开机载入程序，可以支持多种不同的计算机系统结构，包括PPC、ARM、AVR32、MIPS、x86、68k、Nios与MicroBlaze。</li><li>vivi是由mizi公司设计为ARM处理器系列设计的一个bootloader.</li><li>Redboot (Red Hat Embedded Debug and Bootstrap)是Red
Hat公司开发的一个独立运行在嵌入式系统上的BootLoader程序，是目前比较流行的一个功能、可移植性好的BootLoader。</li></ul><p>2. 关于“裸机编程(Bare-Metal)”:</p><p>微控制器开发人员很熟悉这个概念，
Bare-Metal是指的你的程序和处理器之间没有任何东西&mdash;-你写的程序将直接运行在处理器上,
换言之，开发人员是在直接操控硬件。在裸机编程的场景中，需要由开发人员检查并排除任何一个可以导致系统崩溃的风险。</p><p>&ldquo;Bare-Metal"要求开发人员了解关于硬件的细节，所以接下来我们将对编译链和qemu本身进行分析。</p><p>3. 下载qemu源码包并查询相关硬件信息：</p><p>ArchLinux采用ABS(Arch Build
System)来管理源码包，下面的步骤将qemu源码包下载到本地，更详细的关于ABS的操作可以在ArchLinux的Wiki中找到</p><pre><code>	$ pacman -S abs
	$ pacman -Ss qemu
	extra/qemu 1.4.2-2 [installed]
	$ abs extra/qemu 
	$ cp -r /var/abs/extra/qemu/ ~/abs 
	$ cd ~/abs &amp;&amp; makepkg -s --asroot -o
</code></pre><p>得到versatilepb开发板的CPU型号, 可以看到"arm926"是我们要的结果。</p><pre><code>	$ grep &quot;arm&quot; src/qemu-1.4.2/hw/versatilepb.c 
	#include &quot;arm-misc.h&quot;
	static struct arm_boot_info versatile_binfo;
	        args-&gt;cpu_model = &quot;arm926&quot;;
	    cpu = cpu_arm_init(args-&gt;cpu_model);
	    cpu_pic = arm_pic_init_cpu(cpu);
	    arm_load_kernel(cpu, &amp;versatile_binfo);
</code></pre><p>得到versatilepb开发板的串口寄存器硬件信息：</p><pre><code>	$ grep &quot;UART*&quot; src/qemu-1.4.2/hw/versatilepb.c 
	    /*  0x10009000 UART3.  */
	    /*  0x101f1000 UART0.  */
	    /*  0x101f2000 UART1.  */
	    /*  0x101f3000 UART2.  */
</code></pre><p>所以说开源是王道嘛，很快就查到了每一个需要了解的细节。UART0在内存中map到的地址是0x101f1000,
我们直接往这个地址写数据，就可以在终端上看到数据输出了。</p><p>4. 查看编译链支持的平台：</p><pre><code>	$ cat ~/CodeSourcery/Sourcery_CodeBench_Lite_for_ARM_EABI/share/doc/arm-arm-none-eabi/info/gcc.info | grep arm926
	     `arm926ej-s', `arm940t', `arm9tdmi', `arm10tdmi', `arm1020t',
</code></pre><p>arm926ej-s是被支持的，因此我们可以用这套编译链来生成需要的裸机调试代码。</p><p>5. 启动应用程序init.c的编写:</p><p>首先创建应用程序init.c：</p><pre><code>volatile unsigned char * const UART0_PTR = (unsigned char *)0x0101f1000;
void display(const char *string){
    while(*string != '\0'){
        *UART0_PTR = *string;
        string++;
    }
}
 
int my_init(){
    display(&quot;Hello Open World\n&quot;);
}
</code></pre><p>init.c中，我们首先声明一个volatile变UART0_PTR,volatile关键字用于告知编译器此变量是用于直接访问内存映像设备的，即串口0内存地址</p><p>display()函数则是用于将字符串中的字符按顺序输出到串口0, 直到遇到字符串结尾。</p><p>my_init()调用了display(), 接下来我们将把它作为C入口函数.</p><p>预编译init.c:</p><pre><code>	$ arm-none-eabi-gcc -c -mcpu=arm926ej-s init.c -o init.o
</code></pre><p>6. 启动代码start.s编写：</p><pre><code>.global _Start
_Start:
LDR sp, = sp_top
BL my_init
B .
</code></pre><p>处理器加电后，将跳转到指定的内存地址,从此地址开始读入并执行代码。</p><p>_Start被声明为全局函数，_Start的实现中，首先将栈地址指向sp_top, LDR(load),
sp是栈地址寄存器(stack pointer),</p><p>BL则是跳转指令，跳转到my_init函数，事实上你可以跳转到任何一个你想跳转的函数，临时写一个their_init()跳转过去也行。Debug时常更改这里以调试不同的子系统功能。</p><p>&ldquo;B.&ldquo;可以理解为汇编里的while(1)或for(;;)循环，处理器空转，什么也不做。如果不调用它，系统就会崩溃。所谓嵌入式编程的一个基本理念就是，代码无限循环。</p><p>预编译汇编文件start.s:
$ arm-none-eabi-as -mcpu=arm926ej-s startup.s -o startup.o</p><p>7. 接下来我们需要用一个可以被编译器识别的链接脚本链接两文件, linker.ld:</p><pre><code>	ENTRY(_Start)
	SECTIONS
	{
	. = 0x10000;
	startup : { startup.o(.text)}
	.data : {*(.data)}
	.bss : {*(.bss)}
	. = . + 0x500;
	sp_top = .;
	}
</code></pre><p>ENTRY(_Start)用于告知链接器程序的入口点(entry point)是_Start(start.s中定义).
Qemu模拟器如果加上-kernel选项时，将自动从0x10000开始执行，所以我们必须将代码放到这个地址。所以第四行我们指定&rdquo;.
= 0x10000&rdquo;. SECTIONS就是用于定义程序的不同部分的。</p><p>startup.o组成了代码的text部分，然后是data部分和bss部分，最后一步则定义了栈指针(sp,
stack pointer)地址. 栈通常是向下增长的，所以最好给它一个比较安全的地址， . =
.+0x500就是用于避免栈被改写的。sp_top用于存储栈顶地址。</p><p>有关程序结构：</p><ul><li>BSS段: 在采用段式内存管理的架构中，BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS是英文Block Started by Symbol的简称。BSS段属于静态内存分配。.bss section的空间结构类似于stack, 主要用于存储静态变量、未显式初始化、在变量使用前由运行时初始化为零。</li><li>数据段(data segment): 通常是指用来存放程序中已初始化且不为0的全局变量的一块内存区域。数据段属于静态内存分配。</li><li>代码段(code segment/text segment): 通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读,某些架构也允许代码段为可写，即允许程序自修改。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li></ul><p>编译:</p><pre><code>	$ arm-none-eabi-ld -T linker.ld init.o startup.o -o output.elf
	$ file output.elf 
	output.elf: ELF 32-bit LSB  executable, ARM, EABI5 version 1 (SYSV),statically linked, not stripped
	$  arm-none-eabi-objcopy -O binary output.elf output.bin
	$ file output.bin 
	output.bin: data
</code></pre><p>8. 使用qemu-system-arm运行output.bin:</p><pre><code>	$ qemu-system-arm --help | grep nographic 
	-nographic      disable graphical output and redirect serial I/Os to console.
	$ qemu-system-arm -M versatilepb -nographic -kernel output.bin
	Hello Open World
</code></pre><p>9. Play more tricks:
改动init.c里的串口输出地址为串口1：</p><pre><code>	volatile unsigned char * const UART0_PTR = (unsigned char *)0x0101f2000;
		// 0x101f1000  --&gt; 0x101f2000
</code></pre><p>按照步骤3～7里重新编译，并运行以查看结果:</p><pre><code>	# 没有反应！
	$ qemu-system-arm -M versatilepb -nographic -kernel output.bin
	# 终端有输出字符。
	$ qemu-system-arm -M versatilepb -kernel output.bin -serial vc:800x600 -serial stdio
	Hello Open World
</code></pre><p>同样你也可以把字符输出到第三个串口，只不过前两个-serial的重定向需要指定到别的设备而已。</p></div><ul class=pagination><li class=page-item><a href=/ class=page-link aria-label=First><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/page/221/ class=page-link aria-label=Previous><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a class=page-link href=/>1</a></li><li class=page-item><a class=page-link href=/page/2/>2</a></li><li class=page-item><a class=page-link href=/page/3/>3</a></li><li class="page-item disabled"><span aria-hidden=true>&nbsp;&mldr;&nbsp;</span></li><li class=page-item><a class=page-link href=/page/221/>221</a></li><li class="page-item active"><a class=page-link href=/page/222/>222</a></li><li class=page-item><a class=page-link href=/page/223/>223</a></li><li class=page-item><a class=page-link href=/page/224/>224</a></li><li class=page-item><a href=/page/223/ class=page-link aria-label=Next><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/page/224/ class=page-link aria-label=Last><span aria-hidden=true>&#187;&#187;</span></a></li></ul></div></div><script src=http://purplepalmdash.github.io/js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script></body></html>